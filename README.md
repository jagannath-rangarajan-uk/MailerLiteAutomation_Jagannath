# MailerLite Automation

This project automates two key test cases for the MailerLite application, using **Selenium**, **TestNG**, and **Page Object Model (POM)**.

## Project Setup

### Prerequisites
- Java 11 or above
- Maven
- Git
- An IDE like IntelliJ IDEA or Eclipse

### Steps to Set Up and Run:

1. **Clone the repository:**

    ```bash
    git clone https://github.com/your-repo/MailerLiteAutomation.git
    cd MailerLiteAutomation
    ```

2. **Install dependencies:**

    ```bash
    mvn install
    ```

3. **Run the tests using Maven:**

    ```bash
    mvn test
    ```

4. **View the Test Report:**
   After running the tests, view the HTML report generated by ExtentReports in the `target/extent-report.html`.

### Test Cases:
1. **TC_0001:** Verify that an email is received correctly after sending a campaign.
2. **TC_0002:** Verify that a subscriber is unsubscribed successfully.

### Configuration:
- Update any necessary configurations (e.g., URL, credentials) in the page classes.

**Tech Stack & Framework**
Java as the programming language.
Selenium WebDriver for automating web interactions.
TestNG for structuring the test cases and generating reports.
Page Object Model (POM) design pattern for code reusability and maintainability.
Maven for dependency management.
ExtentReports for generating the test report.
**Test Cases Breakdown**
**TC_0001: Verify Email Reception After Sending a Campaign**
In this test, we need to simulate the process of creating and sending a campaign, and then verify if the email arrives with the correct details (sender, subject, etc.).

**TC_0002: Verify Unsubscription from an Email**
Here, we simulate the process of unsubscribing from a campaign email and check if the user is marked as unsubscribed in the system.

**Why I chose this tech stack and design pattern:**
Java is widely used in test automation.
Selenium WebDriver is highly versatile for web automation.
TestNG allows for easy management of test cases, data-driven tests, and reporting.
POM helps in reducing code duplication and increases maintainability.

**Handling Multiple Environments:**
Use a configuration file to store environment-specific URLs, credentials, etc.
Implement dynamic loading of configuration based on the environment.

**Classifying Tests into Suites:**
Tests can be grouped into Smoke, Regression, and Functional suites.
Use TestNG @Suite annotations to create separate test suites.

**CI/CD Integration:**
Add Maven/Gradle build steps to your CI pipeline.
Integrate with Jenkins to pull the latest code, run tests, and generate reports.

**Additional Implementation Notes:**
Ensure that proper logging is implemented for debugging purposes.
Use WebDriverManager for automatic WebDriver management.
